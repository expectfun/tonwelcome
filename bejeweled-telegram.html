<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Bejeweled - Telegram Mini App</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --tg-theme-bg-color: #0a0a1a;
            --tg-theme-text-color: #ffffff;
            --tg-theme-hint-color: #aaaaaa;
            --tg-theme-button-color: #667eea;
            --tg-theme-button-text-color: #ffffff;
            --tg-theme-secondary-bg-color: #1a1a3a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background: var(--tg-theme-bg-color, #0a0a1a);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            padding: 10px;
            padding-bottom: env(safe-area-inset-bottom, 10px);
        }

        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background-image:
                radial-gradient(2px 2px at 20px 30px, rgba(255,255,255,0.8), transparent),
                radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.6), transparent),
                radial-gradient(1px 1px at 90px 40px, rgba(255,255,255,0.7), transparent),
                radial-gradient(2px 2px at 160px 120px, rgba(255,255,255,0.5), transparent);
            background-size: 200px 150px;
            animation: twinkle 4s ease-in-out infinite;
            opacity: 0.5;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }

        .game-container {
            text-align: center;
            z-index: 1;
            width: 100%;
            max-width: 400px;
        }

        h1 {
            font-size: clamp(24px, 6vw, 36px);
            background: linear-gradient(180deg, #ffd700 0%, #ff8c00 50%, #ffd700 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
            letter-spacing: 4px;
            font-weight: bold;
        }

        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .mode-btn {
            padding: 6px 16px;
            font-size: 12px;
            background: var(--tg-theme-secondary-bg-color, #1a1a3a);
            color: var(--tg-theme-hint-color, #888);
            border: 1px solid #3a3a5a;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-btn.active {
            background: var(--tg-theme-button-color, #667eea);
            color: var(--tg-theme-button-text-color, white);
            border-color: var(--tg-theme-button-color, #667eea);
        }

        .timer-display {
            font-size: 24px;
            color: #4ecdc4;
            font-weight: bold;
            margin-bottom: 5px;
            display: none;
        }

        .timer-display.active {
            display: block;
        }

        .timer-display.warning { color: #f7b733; }
        .timer-display.critical { color: #fc4a1a; animation: pulse 0.3s ease infinite; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .timer-bar {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            margin-bottom: 8px;
            overflow: hidden;
            display: none;
        }

        .timer-bar.active { display: block; }

        .timer-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            border-radius: 3px;
            transition: width 0.1s linear;
        }

        .timer-fill.warning { background: linear-gradient(90deg, #f7b733, #fc4a1a); }
        .timer-fill.critical { background: linear-gradient(90deg, #fc4a1a, #cc0000); }

        .info-bar {
            display: flex;
            justify-content: center;
            gap: 25px;
            margin-bottom: 10px;
        }

        .info-item {
            color: var(--tg-theme-hint-color, #aaa);
            font-size: 11px;
            text-transform: uppercase;
        }

        .info-item span {
            display: block;
            color: #ffd700;
            font-size: 18px;
            font-weight: bold;
        }

        .board-frame {
            background: var(--tg-theme-secondary-bg-color, #1a1a3a);
            padding: 8px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            margin: 0 auto;
            display: inline-block;
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            background: rgba(0,0,0,0.3);
            padding: 4px;
            border-radius: 8px;
            width: min(calc(100vw - 50px), 340px);
            height: min(calc(100vw - 50px), 340px);
        }

        .cell {
            aspect-ratio: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .gem {
            width: 90%;
            height: 90%;
            cursor: pointer;
            transition: transform 0.15s ease;
            position: relative;
            border-radius: 4px;
        }

        .gem:active {
            transform: scale(1.1);
        }

        .gem.selected {
            animation: gemPulse 0.5s ease infinite;
        }

        .gem.hint {
            animation: hintPulse 0.8s ease infinite;
        }

        @keyframes gemPulse {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.1); filter: brightness(1.3); }
        }

        @keyframes hintPulse {
            0%, 100% { transform: scale(1); box-shadow: none; }
            50% { transform: scale(1.1); box-shadow: 0 0 15px rgba(255,255,255,0.8); }
        }

        .gem.matched {
            animation: explode 0.4s ease forwards;
        }

        @keyframes explode {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3) rotate(180deg); opacity: 0.5; }
            100% { transform: scale(0) rotate(360deg); opacity: 0; }
        }

        .gem.falling {
            animation: drop 0.3s ease;
        }

        @keyframes drop {
            0% { transform: translateY(-100%); opacity: 0; }
            60% { transform: translateY(5%); }
            100% { transform: translateY(0); opacity: 1; }
        }

        .gem svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));
        }

        .gem-red svg { filter: drop-shadow(0 0 6px rgba(255, 50, 50, 0.5)); }
        .gem-blue svg { filter: drop-shadow(0 0 6px rgba(50, 150, 255, 0.5)); }
        .gem-green svg { filter: drop-shadow(0 0 6px rgba(50, 255, 100, 0.5)); }
        .gem-yellow svg { filter: drop-shadow(0 0 6px rgba(255, 220, 50, 0.5)); }
        .gem-purple svg { filter: drop-shadow(0 0 6px rgba(180, 100, 255, 0.5)); }
        .gem-white svg { filter: drop-shadow(0 0 6px rgba(255, 255, 255, 0.5)); }
        .gem-orange svg { filter: drop-shadow(0 0 6px rgba(255, 150, 50, 0.5)); }

        .gem.flame-gem { animation: flameGlow 0.8s ease infinite; }
        .gem.flame-gem::after {
            content: '';
            position: absolute;
            bottom: -2px;
            right: -2px;
            width: 12px;
            height: 12px;
            background: radial-gradient(circle, #ff6600, transparent);
            border-radius: 50%;
        }

        @keyframes flameGlow {
            0%, 100% { box-shadow: 0 0 8px rgba(255, 100, 0, 0.6); }
            50% { box-shadow: 0 0 15px rgba(255, 150, 0, 0.9); }
        }

        .gem.star-gem { animation: starGlow 0.6s ease infinite; }
        .gem.star-gem::after {
            content: '';
            position: absolute;
            bottom: -2px;
            right: -2px;
            width: 12px;
            height: 12px;
            background: radial-gradient(circle, #ffff00, transparent);
            border-radius: 50%;
        }

        @keyframes starGlow {
            0%, 100% { box-shadow: 0 0 8px rgba(255, 255, 100, 0.6); }
            50% { box-shadow: 0 0 18px rgba(255, 255, 150, 1); }
        }

        .gem.hypercube { animation: hypercubeGlow 0.5s ease infinite; }

        @keyframes hypercubeGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 255, 255, 0.8); filter: hue-rotate(0deg); }
            50% { box-shadow: 0 0 20px rgba(255, 255, 255, 1); filter: hue-rotate(180deg); }
        }

        .buttons {
            margin-top: 12px;
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 18px;
            font-size: 13px;
            background: var(--tg-theme-secondary-bg-color, #2a2a4a);
            color: var(--tg-theme-text-color, #ddd);
            border: 1px solid #3a3a5a;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:active {
            transform: scale(0.95);
            background: var(--tg-theme-button-color, #667eea);
        }

        .score-popup {
            position: fixed;
            pointer-events: none;
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.8);
            animation: scoreFloat 1s ease forwards;
            z-index: 100;
        }

        @keyframes scoreFloat {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-40px) scale(1.2); opacity: 0; }
        }

        .time-bonus {
            position: fixed;
            pointer-events: none;
            font-size: 20px;
            font-weight: bold;
            color: #4ecdc4;
            text-shadow: 0 0 8px rgba(78, 205, 196, 0.8);
            animation: timeBonusFloat 1s ease forwards;
            z-index: 100;
        }

        @keyframes timeBonusFloat {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-30px) scale(1.1); opacity: 0; }
        }

        .cascade-text {
            position: fixed;
            pointer-events: none;
            font-size: 28px;
            font-weight: bold;
            color: #ff6b6b;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.8);
            animation: cascadeFloat 1.2s ease forwards;
            z-index: 100;
        }

        @keyframes cascadeFloat {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            80% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -100%) scale(0.8); opacity: 0; }
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .game-over-content {
            text-align: center;
            padding: 30px;
            background: var(--tg-theme-secondary-bg-color, #1a1a3a);
            border-radius: 16px;
            max-width: 90%;
        }

        .game-over h2 {
            font-size: 28px;
            color: #ffd700;
            margin-bottom: 15px;
        }

        .game-over p {
            font-size: 18px;
            color: var(--tg-theme-text-color, white);
            margin-bottom: 20px;
        }

        .hidden { display: none !important; }

        .lightning {
            position: fixed;
            pointer-events: none;
            background: linear-gradient(90deg, transparent, white, transparent);
            animation: lightningFlash 0.3s ease forwards;
            z-index: 50;
        }

        @keyframes lightningFlash {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        .explosion {
            position: fixed;
            pointer-events: none;
            border-radius: 50%;
            animation: explodeRing 0.5s ease forwards;
            z-index: 50;
        }

        @keyframes explodeRing {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(2.5); opacity: 0; }
        }

        .blitz-countdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            animation: countdownPop 0.8s ease forwards;
            z-index: 150;
        }

        @keyframes countdownPop {
            0% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            80% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
        }

        /* Touch feedback */
        .gem.touching {
            transform: scale(1.15);
            z-index: 10;
        }

        .swipe-indicator {
            position: fixed;
            pointer-events: none;
            width: 30px;
            height: 30px;
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            animation: swipeRipple 0.4s ease forwards;
            z-index: 50;
        }

        @keyframes swipeRipple {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        /* Prevent selection */
        .game-container {
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            overscroll-behavior-y: contain;
        }
    </style>
</head>
<body>
    <div class="stars"></div>

    <div class="game-container">
        <h1>BEJEWELED</h1>

        <div class="mode-selector">
            <button class="mode-btn active" id="mode-classic" onclick="setMode('classic')">Classic</button>
            <button class="mode-btn" id="mode-blitz" onclick="setMode('blitz')">Blitz</button>
        </div>

        <div class="timer-display" id="timer-display">1:00</div>
        <div class="timer-bar" id="timer-bar">
            <div class="timer-fill" id="timer-fill" style="width: 100%"></div>
        </div>

        <div class="info-bar">
            <div class="info-item">Score<span id="score">0</span></div>
            <div class="info-item" id="level-container">Level<span id="level">1</span></div>
            <div class="info-item" id="goal-container">Goal<span id="goal">1000</span></div>
        </div>

        <div class="board-frame">
            <div id="game-board"></div>
        </div>

        <div class="buttons">
            <button class="btn" onclick="showHint()">Hint</button>
            <button class="btn" onclick="resetGame()">New Game</button>
        </div>
    </div>

    <div id="game-over" class="game-over hidden">
        <div class="game-over-content">
            <h2 id="game-over-title">GAME OVER</h2>
            <p>Final Score: <span id="final-score">0</span></p>
            <button class="btn" onclick="resetGame()">Play Again</button>
        </div>
    </div>

    <script>
        // Telegram WebApp integration
        const tg = window.Telegram?.WebApp;

        if (tg) {
            tg.ready();
            tg.expand();

            // Apply Telegram theme
            if (tg.themeParams) {
                document.documentElement.style.setProperty('--tg-theme-bg-color', tg.themeParams.bg_color || '#0a0a1a');
                document.documentElement.style.setProperty('--tg-theme-text-color', tg.themeParams.text_color || '#ffffff');
                document.documentElement.style.setProperty('--tg-theme-hint-color', tg.themeParams.hint_color || '#aaaaaa');
                document.documentElement.style.setProperty('--tg-theme-button-color', tg.themeParams.button_color || '#667eea');
                document.documentElement.style.setProperty('--tg-theme-button-text-color', tg.themeParams.button_text_color || '#ffffff');
                document.documentElement.style.setProperty('--tg-theme-secondary-bg-color', tg.themeParams.secondary_bg_color || '#1a1a3a');
            }
        }

        // Haptic feedback helper
        function haptic(type = 'light') {
            if (tg?.HapticFeedback) {
                if (type === 'light') tg.HapticFeedback.impactOccurred('light');
                else if (type === 'medium') tg.HapticFeedback.impactOccurred('medium');
                else if (type === 'heavy') tg.HapticFeedback.impactOccurred('heavy');
                else if (type === 'success') tg.HapticFeedback.notificationOccurred('success');
                else if (type === 'error') tg.HapticFeedback.notificationOccurred('error');
            }
        }

        const BOARD_SIZE = 8;
        const GEM_TYPES = [
            { name: 'red', colors: ['#ff4444', '#cc0000', '#ff6666', '#990000'] },
            { name: 'blue', colors: ['#4488ff', '#0044cc', '#66aaff', '#002299'] },
            { name: 'green', colors: ['#44dd44', '#00aa00', '#66ff66', '#007700'] },
            { name: 'yellow', colors: ['#ffdd00', '#ccaa00', '#ffee44', '#997700'] },
            { name: 'purple', colors: ['#bb66ff', '#8833cc', '#dd99ff', '#6600aa'] },
            { name: 'white', colors: ['#ffffff', '#cccccc', '#ffffff', '#999999'] },
            { name: 'orange', colors: ['#ff8800', '#cc5500', '#ffaa44', '#993300'] }
        ];

        const HYPERCUBE = { name: 'hypercube', colors: ['#ffffff', '#aaaaaa', '#ffffff', '#888888'], special: 'hypercube' };

        let board = [];
        let selectedTile = null;
        let score = 0;
        let level = 1;
        let goal = 1000;
        let isAnimating = false;
        let hintTiles = [];

        // Game mode
        let gameMode = 'classic';
        let blitzTime = 60;
        let timeRemaining = 60;
        let timerInterval = null;
        let gameStarted = false;

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTile = null;
        let isTouching = false;
        const SWIPE_THRESHOLD = 25;

        function createGemSVG(colors) {
            return `
                <svg viewBox="0 0 100 100">
                    <defs>
                        <linearGradient id="grad-${colors[0].replace('#','')}" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:${colors[2]};stop-opacity:1" />
                            <stop offset="50%" style="stop-color:${colors[0]};stop-opacity:1" />
                            <stop offset="100%" style="stop-color:${colors[3]};stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <polygon points="50,5 95,35 95,70 50,95 5,70 5,35"
                             fill="url(#grad-${colors[0].replace('#','')})"
                             stroke="${colors[1]}"
                             stroke-width="2"/>
                    <polygon points="50,5 75,25 50,40 25,25"
                             fill="${colors[2]}"
                             opacity="0.6"/>
                    <polygon points="5,35 25,25 50,40 50,70 5,70"
                             fill="${colors[1]}"
                             opacity="0.4"/>
                    <polygon points="95,35 75,25 50,40 50,70 95,70"
                             fill="${colors[2]}"
                             opacity="0.3"/>
                    <ellipse cx="35" cy="25" rx="8" ry="4"
                             fill="white"
                             opacity="0.6"/>
                </svg>
            `;
        }

        function createHypercubeSVG() {
            return `
                <svg viewBox="0 0 100 100">
                    <defs>
                        <linearGradient id="hypercube-grad" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#ffffff;stop-opacity:1" />
                            <stop offset="50%" style="stop-color:#aaddff;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ffffff;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <polygon points="50,5 95,50 50,95 5,50"
                             fill="url(#hypercube-grad)"
                             stroke="#88ccff"
                             stroke-width="2"/>
                    <polygon points="50,20 80,50 50,80 20,50"
                             fill="rgba(200,230,255,0.5)"
                             stroke="#aaddff"
                             stroke-width="1"/>
                    <polygon points="50,35 65,50 50,65 35,50"
                             fill="rgba(255,255,255,0.8)"
                             stroke="#ccddff"
                             stroke-width="1"/>
                    <circle cx="50" cy="50" r="5" fill="white"/>
                </svg>
            `;
        }

        function init() {
            createBoard();
            removeInitialMatches();
            renderBoard();
            if (!hasValidMoves()) {
                init();
            }
        }

        function createBoard() {
            board = [];
            for (let row = 0; row < BOARD_SIZE; row++) {
                board[row] = [];
                for (let col = 0; col < BOARD_SIZE; col++) {
                    board[row][col] = getRandomGem();
                }
            }
        }

        function removeInitialMatches() {
            let hasMatches = true;
            while (hasMatches) {
                const matches = findMatches();
                if (matches.length > 0) {
                    matches.forEach(m => {
                        board[m.row][m.col] = getRandomGem();
                    });
                } else {
                    hasMatches = false;
                }
            }
        }

        function getRandomGem() {
            const gem = GEM_TYPES[Math.floor(Math.random() * GEM_TYPES.length)];
            return { ...gem, special: null };
        }

        function renderBoard() {
            const gameBoard = document.getElementById('game-board');
            gameBoard.innerHTML = '';

            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';

                    const gemData = board[row][col];
                    const gem = document.createElement('div');
                    gem.className = `gem gem-${gemData.name}`;

                    if (gemData.special === 'flame') gem.classList.add('flame-gem');
                    else if (gemData.special === 'star') gem.classList.add('star-gem');
                    else if (gemData.special === 'hypercube') gem.classList.add('hypercube');

                    gem.innerHTML = gemData.special === 'hypercube' ? createHypercubeSVG() : createGemSVG(gemData.colors);

                    gem.dataset.row = row;
                    gem.dataset.col = col;
                    gem.addEventListener('click', () => handleGemClick(row, col));
                    gem.addEventListener('touchstart', (e) => handleTouchStart(e, row, col), { passive: false });
                    gem.addEventListener('touchmove', (e) => handleTouchMove(e), { passive: false });
                    gem.addEventListener('touchend', (e) => handleTouchEnd(e), { passive: false });

                    cell.appendChild(gem);
                    gameBoard.appendChild(cell);
                }
            }
        }

        async function handleGemClick(row, col) {
            if (isAnimating) return;

            if (gameMode === 'blitz' && !gameStarted && !timerInterval) {
                isAnimating = true;
                await startBlitzCountdown();
                isAnimating = false;
            }

            if (gameMode === 'blitz' && !gameStarted && timerInterval === null) return;

            clearHints();
            const clicked = { row, col };

            if (!selectedTile) {
                selectedTile = clicked;
                highlightGem(row, col);
                haptic('light');
            } else {
                if (selectedTile.row === row && selectedTile.col === col) {
                    clearSelection();
                    selectedTile = null;
                } else if (isAdjacent(selectedTile, clicked)) {
                    haptic('medium');
                    swapGems(selectedTile, clicked);
                } else {
                    clearSelection();
                    selectedTile = clicked;
                    highlightGem(row, col);
                    haptic('light');
                }
            }
        }

        function handleTouchStart(e, row, col) {
            if (isAnimating) return;
            e.preventDefault();

            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartTile = { row, col };
            isTouching = true;

            const gem = e.target.closest('.gem');
            if (gem) gem.classList.add('touching');
        }

        function handleTouchMove(e) {
            if (!isTouching || !touchStartTile) return;
            e.preventDefault();
        }

        async function handleTouchEnd(e) {
            if (!isTouching || !touchStartTile) return;
            e.preventDefault();

            document.querySelectorAll('.gem.touching').forEach(g => g.classList.remove('touching'));

            const touch = e.changedTouches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            const absDeltaX = Math.abs(deltaX);
            const absDeltaY = Math.abs(deltaY);

            if (absDeltaX < SWIPE_THRESHOLD && absDeltaY < SWIPE_THRESHOLD) {
                isTouching = false;
                await handleGemClick(touchStartTile.row, touchStartTile.col);
                touchStartTile = null;
                return;
            }

            let targetTile = null;

            if (absDeltaX > absDeltaY) {
                if (deltaX > SWIPE_THRESHOLD && touchStartTile.col < BOARD_SIZE - 1) {
                    targetTile = { row: touchStartTile.row, col: touchStartTile.col + 1 };
                } else if (deltaX < -SWIPE_THRESHOLD && touchStartTile.col > 0) {
                    targetTile = { row: touchStartTile.row, col: touchStartTile.col - 1 };
                }
            } else {
                if (deltaY > SWIPE_THRESHOLD && touchStartTile.row < BOARD_SIZE - 1) {
                    targetTile = { row: touchStartTile.row + 1, col: touchStartTile.col };
                } else if (deltaY < -SWIPE_THRESHOLD && touchStartTile.row > 0) {
                    targetTile = { row: touchStartTile.row - 1, col: touchStartTile.col };
                }
            }

            if (targetTile && !isAnimating) {
                if (gameMode === 'blitz' && !gameStarted && !timerInterval) {
                    isAnimating = true;
                    await startBlitzCountdown();
                    isAnimating = false;
                }

                if (gameMode === 'blitz' && !gameStarted && timerInterval === null) {
                    isTouching = false;
                    touchStartTile = null;
                    return;
                }

                clearSelection();
                clearHints();
                selectedTile = null;
                haptic('medium');
                createSwipeIndicator(touchStartTile.row, touchStartTile.col);
                await swapGems(touchStartTile, targetTile);
            }

            isTouching = false;
            touchStartTile = null;
        }

        function createSwipeIndicator(row, col) {
            const boardEl = document.getElementById('game-board');
            const rect = boardEl.getBoundingClientRect();
            const cellSize = rect.width / BOARD_SIZE;

            const indicator = document.createElement('div');
            indicator.className = 'swipe-indicator';
            indicator.style.left = (rect.left + col * cellSize + cellSize / 2 - 15) + 'px';
            indicator.style.top = (rect.top + row * cellSize + cellSize / 2 - 15) + 'px';
            document.body.appendChild(indicator);
            setTimeout(() => indicator.remove(), 400);
        }

        function isAdjacent(t1, t2) {
            const rowDiff = Math.abs(t1.row - t2.row);
            const colDiff = Math.abs(t1.col - t2.col);
            return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
        }

        function highlightGem(row, col) {
            const gems = document.querySelectorAll('.gem');
            gems[row * BOARD_SIZE + col].classList.add('selected');
        }

        function clearSelection() {
            document.querySelectorAll('.gem.selected').forEach(g => g.classList.remove('selected'));
        }

        function clearHints() {
            document.querySelectorAll('.gem.hint').forEach(g => g.classList.remove('hint'));
            hintTiles = [];
        }

        async function swapGems(t1, t2) {
            isAnimating = true;
            clearSelection();

            const gem1 = board[t1.row][t1.col];
            const gem2 = board[t2.row][t2.col];

            // Hypercube swap
            if (gem1.special === 'hypercube' || gem2.special === 'hypercube') {
                const hypercubePos = gem1.special === 'hypercube' ? t1 : t2;
                const targetGem = gem1.special === 'hypercube' ? gem2 : gem1;

                await activateHypercube(hypercubePos, targetGem.name);
                await processMatches();
                checkLevelUp();

                if (!hasValidMoves()) gameOver();
                selectedTile = null;
                isAnimating = false;
                return;
            }

            // Normal swap
            const temp = board[t1.row][t1.col];
            board[t1.row][t1.col] = board[t2.row][t2.col];
            board[t2.row][t2.col] = temp;

            renderBoard();

            const matches = findMatches();
            if (matches.length > 0) {
                await processMatches(t1, t2);
                checkLevelUp();
                if (!hasValidMoves()) gameOver();
            } else {
                await sleep(150);
                haptic('error');
                // Swap back
                const temp = board[t1.row][t1.col];
                board[t1.row][t1.col] = board[t2.row][t2.col];
                board[t2.row][t2.col] = temp;
                renderBoard();
            }

            selectedTile = null;
            isAnimating = false;
        }

        async function activateHypercube(pos, targetColor) {
            haptic('heavy');

            const targets = [];
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col].name === targetColor) {
                        targets.push({ row, col });
                    }
                }
            }
            targets.push(pos);

            const boardEl = document.getElementById('game-board');
            const rect = boardEl.getBoundingClientRect();
            targets.forEach(t => createLightning(rect, pos, t));

            await sleep(300);

            const gems = document.querySelectorAll('.gem');
            targets.forEach(t => {
                gems[t.row * BOARD_SIZE + t.col].classList.add('matched');
            });

            const points = targets.length * 20;
            score += points;
            document.getElementById('score').textContent = score;
            showScorePopup(points, pos.row, pos.col);

            await sleep(400);

            targets.forEach(t => {
                board[t.row][t.col] = null;
            });

            dropGems();
            fillBoard();
            renderBoard();
        }

        function createLightning(boardRect, from, to) {
            const cellSize = boardRect.width / BOARD_SIZE;
            const x1 = boardRect.left + (from.col * cellSize) + cellSize / 2;
            const y1 = boardRect.top + (from.row * cellSize) + cellSize / 2;
            const x2 = boardRect.left + (to.col * cellSize) + cellSize / 2;
            const y2 = boardRect.top + (to.row * cellSize) + cellSize / 2;

            const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

            const lightning = document.createElement('div');
            lightning.className = 'lightning';
            lightning.style.width = length + 'px';
            lightning.style.height = '3px';
            lightning.style.left = x1 + 'px';
            lightning.style.top = y1 + 'px';
            lightning.style.transformOrigin = '0 50%';
            lightning.style.transform = `rotate(${angle}deg)`;

            document.body.appendChild(lightning);
            setTimeout(() => lightning.remove(), 300);
        }

        function findMatches() {
            const matches = new Set();
            const matchGroups = [];

            // Horizontal
            for (let row = 0; row < BOARD_SIZE; row++) {
                let col = 0;
                while (col < BOARD_SIZE) {
                    const gem = board[row][col];
                    if (!gem) { col++; continue; }

                    let matchLen = 1;
                    while (col + matchLen < BOARD_SIZE && board[row][col + matchLen]?.name === gem.name) {
                        matchLen++;
                    }

                    if (matchLen >= 3) {
                        const group = { type: 'horizontal', color: gem.name, length: matchLen, positions: [] };
                        for (let i = 0; i < matchLen; i++) {
                            matches.add(`${row},${col + i}`);
                            group.positions.push({ row, col: col + i });
                        }
                        matchGroups.push(group);
                    }
                    col += Math.max(matchLen, 1);
                }
            }

            // Vertical
            for (let col = 0; col < BOARD_SIZE; col++) {
                let row = 0;
                while (row < BOARD_SIZE) {
                    const gem = board[row][col];
                    if (!gem) { row++; continue; }

                    let matchLen = 1;
                    while (row + matchLen < BOARD_SIZE && board[row + matchLen]?.[col]?.name === gem.name) {
                        matchLen++;
                    }

                    if (matchLen >= 3) {
                        const group = { type: 'vertical', color: gem.name, length: matchLen, positions: [] };
                        for (let i = 0; i < matchLen; i++) {
                            matches.add(`${row + i},${col}`);
                            group.positions.push({ row: row + i, col });
                        }
                        matchGroups.push(group);
                    }
                    row += Math.max(matchLen, 1);
                }
            }

            const result = Array.from(matches).map(m => {
                const [row, col] = m.split(',').map(Number);
                return { row, col };
            });
            result.matchGroups = matchGroups;
            return result;
        }

        function detectSpecialGems(matchGroups, swappedTiles) {
            const specials = [];

            // L/T shapes
            for (let i = 0; i < matchGroups.length; i++) {
                for (let j = i + 1; j < matchGroups.length; j++) {
                    const g1 = matchGroups[i];
                    const g2 = matchGroups[j];

                    if (g1.color !== g2.color || g1.type === g2.type) continue;

                    for (const p1 of g1.positions) {
                        for (const p2 of g2.positions) {
                            if (p1.row === p2.row && p1.col === p2.col) {
                                specials.push({ type: 'star', row: p1.row, col: p1.col, color: g1.color });
                            }
                        }
                    }
                }
            }

            // 5+ matches (hypercube) and 4 matches (flame)
            for (const group of matchGroups) {
                const isPartOfLT = specials.some(s =>
                    group.positions.some(p => p.row === s.row && p.col === s.col)
                );

                if (group.length >= 5 && !isPartOfLT) {
                    let pos = group.positions[Math.floor(group.length / 2)];
                    if (swappedTiles) {
                        const swapInGroup = group.positions.find(p =>
                            (p.row === swappedTiles[0].row && p.col === swappedTiles[0].col) ||
                            (p.row === swappedTiles[1].row && p.col === swappedTiles[1].col)
                        );
                        if (swapInGroup) pos = swapInGroup;
                    }
                    specials.push({ type: 'hypercube', row: pos.row, col: pos.col, color: group.color });
                } else if (group.length === 4 && !isPartOfLT) {
                    let pos = group.positions[Math.floor(group.length / 2)];
                    if (swappedTiles) {
                        const swapInGroup = group.positions.find(p =>
                            (p.row === swappedTiles[0].row && p.col === swappedTiles[0].col) ||
                            (p.row === swappedTiles[1].row && p.col === swappedTiles[1].col)
                        );
                        if (swapInGroup) pos = swapInGroup;
                    }
                    specials.push({ type: 'flame', row: pos.row, col: pos.col, color: group.color });
                }
            }

            return specials;
        }

        async function processMatches(t1 = null, t2 = null) {
            let cascade = 0;
            const swappedTiles = (t1 && t2) ? [t1, t2] : null;
            let isFirstMatch = true;

            while (true) {
                const matches = findMatches();
                if (matches.length === 0) break;

                cascade++;

                // Activate special gems
                const specialsToActivate = [];
                matches.forEach(m => {
                    const gem = board[m.row][m.col];
                    if (gem && gem.special && gem.special !== 'hypercube') {
                        specialsToActivate.push({ ...m, special: gem.special, color: gem.name });
                    }
                });

                // Detect new special gems
                const newSpecials = detectSpecialGems(matches.matchGroups || [], isFirstMatch ? swappedTiles : null);
                isFirstMatch = false;

                const basePoints = matches.length * 10;
                const cascadeBonus = cascade > 1 ? cascade * 50 : 0;
                const points = basePoints + cascadeBonus;
                score += points;

                document.getElementById('score').textContent = score;

                if (cascade > 1) {
                    haptic('success');
                    showCascadeText(cascade);
                } else {
                    haptic('medium');
                }

                // Blitz time bonus
                if (gameMode === 'blitz' && gameStarted) {
                    let timeBonus = 0;
                    if (matches.length >= 5) timeBonus = 3;
                    else if (matches.length >= 4) timeBonus = 2;
                    else if (cascade > 1) timeBonus = 1;

                    if (timeBonus > 0) {
                        timeRemaining = Math.min(timeRemaining + timeBonus, blitzTime + 30);
                        updateTimerDisplay();
                        showTimeBonus(timeBonus);
                    }
                }

                const gems = document.querySelectorAll('.gem');
                matches.forEach(m => {
                    gems[m.row * BOARD_SIZE + m.col].classList.add('matched');
                });

                // Show score popup
                if (matches.length > 0) {
                    const midMatch = matches[Math.floor(matches.length / 2)];
                    showScorePopup(points, midMatch.row, midMatch.col);
                }

                await sleep(350);

                // Activate specials
                for (const special of specialsToActivate) {
                    if (special.special === 'flame') {
                        await activateFlameGem(special);
                    } else if (special.special === 'star') {
                        await activateStarGem(special);
                    }
                }

                // Remove matched gems
                matches.forEach(m => {
                    board[m.row][m.col] = null;
                });

                // Create new special gems
                for (const s of newSpecials) {
                    const gemType = GEM_TYPES.find(g => g.name === s.color) || GEM_TYPES[0];
                    if (s.type === 'hypercube') {
                        board[s.row][s.col] = { ...HYPERCUBE };
                    } else {
                        board[s.row][s.col] = { ...gemType, special: s.type };
                    }
                }

                dropGems();
                fillBoard();
                renderBoard();

                await sleep(200);
            }
        }

        async function activateFlameGem(pos) {
            haptic('heavy');
            const targets = [];
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    const nr = pos.row + dr;
                    const nc = pos.col + dc;
                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc]) {
                        targets.push({ row: nr, col: nc });
                    }
                }
            }

            createExplosion(pos.row, pos.col, '#ff6600');

            const gems = document.querySelectorAll('.gem');
            targets.forEach(t => {
                gems[t.row * BOARD_SIZE + t.col].classList.add('matched');
            });

            await sleep(300);

            targets.forEach(t => {
                board[t.row][t.col] = null;
            });

            const points = targets.length * 15;
            score += points;
            document.getElementById('score').textContent = score;
        }

        async function activateStarGem(pos) {
            haptic('heavy');
            const targets = [];

            // Row
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (board[pos.row][c]) targets.push({ row: pos.row, col: c });
            }
            // Column
            for (let r = 0; r < BOARD_SIZE; r++) {
                if (board[r][pos.col] && r !== pos.row) targets.push({ row: r, col: pos.col });
            }

            createExplosion(pos.row, pos.col, '#ffff00');

            const gems = document.querySelectorAll('.gem');
            targets.forEach(t => {
                gems[t.row * BOARD_SIZE + t.col].classList.add('matched');
            });

            await sleep(300);

            targets.forEach(t => {
                board[t.row][t.col] = null;
            });

            const points = targets.length * 15;
            score += points;
            document.getElementById('score').textContent = score;
        }

        function createExplosion(row, col, color) {
            const boardEl = document.getElementById('game-board');
            const rect = boardEl.getBoundingClientRect();
            const cellSize = rect.width / BOARD_SIZE;

            const explosion = document.createElement('div');
            explosion.className = 'explosion';
            explosion.style.width = '40px';
            explosion.style.height = '40px';
            explosion.style.left = (rect.left + col * cellSize + cellSize / 2 - 20) + 'px';
            explosion.style.top = (rect.top + row * cellSize + cellSize / 2 - 20) + 'px';
            explosion.style.background = `radial-gradient(circle, ${color}, transparent)`;
            document.body.appendChild(explosion);
            setTimeout(() => explosion.remove(), 500);
        }

        function dropGems() {
            for (let col = 0; col < BOARD_SIZE; col++) {
                let emptyRow = BOARD_SIZE - 1;
                for (let row = BOARD_SIZE - 1; row >= 0; row--) {
                    if (board[row][col] !== null) {
                        if (row !== emptyRow) {
                            board[emptyRow][col] = board[row][col];
                            board[row][col] = null;
                        }
                        emptyRow--;
                    }
                }
            }
        }

        function fillBoard() {
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col] === null) {
                        board[row][col] = getRandomGem();
                    }
                }
            }
        }

        function showScorePopup(points, row, col) {
            const boardEl = document.getElementById('game-board');
            const rect = boardEl.getBoundingClientRect();
            const cellSize = rect.width / BOARD_SIZE;

            const popup = document.createElement('div');
            popup.className = 'score-popup';
            popup.textContent = '+' + points;
            popup.style.left = (rect.left + col * cellSize + cellSize / 2) + 'px';
            popup.style.top = (rect.top + row * cellSize) + 'px';
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 1000);
        }

        function showTimeBonus(seconds) {
            const popup = document.createElement('div');
            popup.className = 'time-bonus';
            popup.textContent = '+' + seconds + 's';
            popup.style.left = '50%';
            popup.style.top = '20%';
            popup.style.transform = 'translateX(-50%)';
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 1000);
        }

        function showCascadeText(cascade) {
            const text = document.createElement('div');
            text.className = 'cascade-text';
            text.textContent = cascade + 'x CASCADE!';
            text.style.left = '50%';
            text.style.top = '50%';
            document.body.appendChild(text);
            setTimeout(() => text.remove(), 1200);
        }

        function hasValidMoves() {
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    // Check right swap
                    if (col < BOARD_SIZE - 1) {
                        swap(row, col, row, col + 1);
                        if (findMatches().length > 0) {
                            swap(row, col, row, col + 1);
                            return true;
                        }
                        swap(row, col, row, col + 1);
                    }
                    // Check down swap
                    if (row < BOARD_SIZE - 1) {
                        swap(row, col, row + 1, col);
                        if (findMatches().length > 0) {
                            swap(row, col, row + 1, col);
                            return true;
                        }
                        swap(row, col, row + 1, col);
                    }
                }
            }
            return false;
        }

        function swap(r1, c1, r2, c2) {
            const temp = board[r1][c1];
            board[r1][c1] = board[r2][c2];
            board[r2][c2] = temp;
        }

        function findHintMove() {
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (col < BOARD_SIZE - 1) {
                        swap(row, col, row, col + 1);
                        if (findMatches().length > 0) {
                            swap(row, col, row, col + 1);
                            return [{ row, col }, { row, col: col + 1 }];
                        }
                        swap(row, col, row, col + 1);
                    }
                    if (row < BOARD_SIZE - 1) {
                        swap(row, col, row + 1, col);
                        if (findMatches().length > 0) {
                            swap(row, col, row + 1, col);
                            return [{ row, col }, { row: row + 1, col }];
                        }
                        swap(row, col, row + 1, col);
                    }
                }
            }
            return null;
        }

        function showHint() {
            if (isAnimating) return;
            clearHints();
            haptic('light');

            const hint = findHintMove();
            if (hint) {
                hintTiles = hint;
                const gems = document.querySelectorAll('.gem');
                hint.forEach(t => {
                    gems[t.row * BOARD_SIZE + t.col].classList.add('hint');
                });
            }
        }

        function checkLevelUp() {
            if (gameMode !== 'classic') return;

            if (score >= goal) {
                level++;
                goal = level * 1000 + (level - 1) * 500;
                document.getElementById('level').textContent = level;
                document.getElementById('goal').textContent = goal;
                haptic('success');
            }
        }

        function setMode(mode) {
            if (isAnimating) return;
            gameMode = mode;

            document.getElementById('mode-classic').classList.toggle('active', mode === 'classic');
            document.getElementById('mode-blitz').classList.toggle('active', mode === 'blitz');

            document.getElementById('timer-display').classList.toggle('active', mode === 'blitz');
            document.getElementById('timer-bar').classList.toggle('active', mode === 'blitz');
            document.getElementById('level-container').style.display = mode === 'classic' ? 'block' : 'none';
            document.getElementById('goal-container').style.display = mode === 'classic' ? 'block' : 'none';

            haptic('light');
            resetGame();
        }

        async function startBlitzCountdown() {
            for (let i = 3; i >= 1; i--) {
                const countdown = document.createElement('div');
                countdown.className = 'blitz-countdown';
                countdown.textContent = i;
                document.body.appendChild(countdown);
                haptic('medium');
                await sleep(800);
                countdown.remove();
            }

            const goText = document.createElement('div');
            goText.className = 'blitz-countdown';
            goText.textContent = 'GO!';
            document.body.appendChild(goText);
            haptic('heavy');
            await sleep(600);
            goText.remove();

            gameStarted = true;
            startTimer();
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                timeRemaining--;
                updateTimerDisplay();

                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                    gameStarted = false;
                    gameOver("TIME'S UP!");
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(timeRemaining / 60);
            const seconds = timeRemaining % 60;
            const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('timer-display').textContent = display;

            const fill = document.getElementById('timer-fill');
            const percent = (timeRemaining / blitzTime) * 100;
            fill.style.width = percent + '%';

            const timerEl = document.getElementById('timer-display');
            timerEl.classList.remove('warning', 'critical');
            fill.classList.remove('warning', 'critical');

            if (timeRemaining <= 10) {
                timerEl.classList.add('critical');
                fill.classList.add('critical');
            } else if (timeRemaining <= 20) {
                timerEl.classList.add('warning');
                fill.classList.add('warning');
            }
        }

        function gameOver(title = 'NO MORE MOVES!') {
            haptic('error');
            document.getElementById('game-over-title').textContent = title;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').classList.remove('hidden');
        }

        function resetGame() {
            document.getElementById('game-over').classList.add('hidden');

            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            score = 0;
            level = 1;
            goal = 1000;
            gameStarted = false;
            timeRemaining = blitzTime;
            selectedTile = null;
            isAnimating = false;

            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('goal').textContent = goal;

            if (gameMode === 'blitz') {
                updateTimerDisplay();
            }

            haptic('medium');
            init();
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Start game
        init();
    </script>
</body>
</html>
